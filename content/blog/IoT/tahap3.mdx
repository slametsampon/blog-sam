---
title: Tahap 3 â€“ Integrasi ESP-Gateway dengan Server Kustom
date: '2024-11-06'
tags: ['kontrol', 'iot', 'esp-32', 'esp-node', 'hortilink', 'sensor', 'web']
draft: false
images: []
summary: Pada Tahap 1, kita akan membahas secara mendetail bagaimana perangkat ESP dapat digunakan dalam Mode Access Point (AP), membuat jaringan Wi-Fi lokal yang memungkinkan perangkat seperti smartphone atau laptop untuk mengakses dan mengontrol sistem hidroponik secara langsung.
---

**Proyek Serial HortiLink: Tahap 3 â€“ Integrasi ESP-Gateway dengan Server Kustom**

---

**Rangkuman Proyek:**

Selamat datang di **Proyek Serial [HortiLink](https://slamet-sam.netlify.app/blog/IoT/HortiLink): Tahap 1 â€“ Pengembangan Sistem Monitoring dan Kontrol Individual (ESP-Node to Device)**!

Siap! Berikut pengantar untuk Tahap 3 dengan gaya santai dan informatif:

---

Setelah persiapan perangkat dan sensor selesai, kini kita memasuki **Tahap 3: Integrasi ESP-Gateway dengan Server Kustom**. Di sinilah semua data mulai hidup dan bekerja untuk kitaâ€”mulai dari koneksi sensor di lapangan hingga server yang menyimpan dan menampilkan data secara real-time!

Di tahap ini, HortiLink berubah dari sekadar perangkat pemantau jadi sistem lengkap yang bisa diakses kapan saja, dari mana saja. Dengan sistem komunikasi antar perangkat IoT yang stabil, server khusus untuk menyimpan data historis, dan dasbor yang keren, kita bisa langsung tahu apa yang terjadi di lahanâ€”termasuk notifikasi real-time yang mengingatkan saat ada yang butuh perhatian ekstra. ðŸŒ±âœ¨

Yuk, simak langkah-langkah seru di Tahap 3 ini!

![hortilink-tahap3](/static/images/IoT/hortilink-tahap1.webp)

**Konsep HortiLink Tahap3 - sumber ChatGpt**

[Seluruh update file tahap1 ini bisa dilihat pada github](https://github.com/slametsampon/HortiLink/tree/main/tahap1)

---

Berikut rangkuman Tahap 3 dari proyek HortiLink dengan gaya santai tapi tetap informatif:

---

**Tahap 3: Integrasi ESP-Gateway dengan Server Kustom**

Di tahap ini, HortiLink mulai lebih canggih dengan menghubungkan perangkat IoT (ESP-Lora) ke server kustom untuk menangkap dan menampilkan data secara real-time! ðŸŽ‰

---

- [**1.1 Pengembangan Komunikasi Antar ESP-Lora**](#11-pengembangan-komunikasi-antar-esp-lora)
- [**1.2 Pengembangan Server Kustom**](#12-pengembangan-server-kustom)
- [**1.3 Pengembangan Dasbor dan Notifikasi Real-Time**](#13-pengembangan-dasbor-dan-notifikasi-real-time)
- [Alasan Pemilihan Sub-Bab 1.2 Pengembangan Server Kustom](#alasan-pemilihan-sub-bab-12-pengembangan-server-kustom)
- [Kreteria rancangan](#kreteria-rancangan)
- [**Setup Project**](#setup-project)
  - [**Lebih lanjut ESLint \& Prettier**](#lebih-lanjut-eslint--prettier)
  - [**Konfigurasi ESLint \& Prettier**](#konfigurasi-eslint--prettier)
- [**Pattern MVC dan Atomic Design**](#pattern-mvc-dan-atomic-design)
- [Hak cipta^1. Artikel ini berdasar ChatGpt \& penulis tidak menjamin seluruh akurasi isinya](#hak-cipta1-artikel-ini-berdasar-chatgpt--penulis-tidak-menjamin-seluruh-akurasi-isinya)

---

### **1.1 Pengembangan Komunikasi Antar ESP-Lora**

- **Koneksi ESP-Lora ke Wi-Fi**: Satu ESP-Lora bertindak sebagai jembatan ke server dengan koneksi Wi-Fi, sementara yang lain berkomunikasi melalui LoRa. Jadi, semua data dari sensor tetap terhubung tanpa harus memiliki Wi-Fi di setiap perangkat!
- **Protokol Komunikasi**: Kita pakai **MQTT** atau **HTTP** untuk mengirim data dari gateway ke server. **MQTT** ideal untuk kirim data kecil secara berkala, cocok banget buat kebutuhan IoT seperti ini.

### **1.2 Pengembangan Server Kustom**

- **Desain Infrastruktur Server**: Buat server khusus HortiLink yang menerima data dari gateway. Server ini bisa di cloud untuk skalabilitas atau di server lokal jika lebih aman dan sesuai kebutuhan internal.
- **Database Time-Series (TSDB)**: Untuk menyimpan data historis sensor, kita gunakan TSDB seperti **InfluxDB**. Dengan ini, kita bisa melacak tren data, misalnya pola kelembapan dan suhu sepanjang waktu.

### **1.3 Pengembangan Dasbor dan Notifikasi Real-Time**

- **Antarmuka Dashboard**: Bangun dasbor real-time yang user-friendly untuk memantau data dari sensor, kontrol perangkat, dan bisa diakses dari mana saja, baik lewat PC maupun mobile.
- **Notifikasi dan Alarm**: Fitur ini penting! Secara otomatis, sistem akan mengirimkan notifikasi saat ada parameter yang melewati batas yang telah ditentukan (misalnya pH atau kelembapan rendah), sehingga pengguna bisa cepat bertindak.

---

### Alasan Pemilihan Sub-Bab 1.2 Pengembangan Server Kustom

Pada **Tahap 3: Integrasi ESP-Gateway dengan Server Kustom**, sub-bab **1.2 Pengembangan Server Kustom** dipilih sebagai fokus utama karena fungsi server yang vital dalam manajemen data sensor, keamanan, dan analisis jangka panjang. Server kustom bukan hanya menjadi pusat pengumpulan data yang diterima dari ESP-Gateway, namun juga berperan dalam menyediakan fondasi untuk pemrosesan data, penyimpanan historis, dan kemudahan akses bagi pengguna akhir.

1. **Sentralisasi Data dan Skalabilitas**

   - Server kustom dirancang untuk menerima dan menyimpan data secara terpusat, memberikan kontrol penuh atas akses, keamanan, dan performa sistem. Pilihan infrastruktur serverâ€”baik cloud maupun lokalâ€”memastikan fleksibilitas dalam menyesuaikan kapasitas dengan kebutuhan proyek di masa depan, terutama jika ada peningkatan volume data atau penambahan perangkat sensor.

2. **Penyimpanan Time-Series untuk Analisis Jangka Panjang**

   - Menggunakan **Time Series Database (TSDB)** seperti InfluxDB, server ini dapat menyimpan data sensor secara historis, memfasilitasi pemantauan tren serta analisis data jangka panjang. Penyimpanan yang berbasis waktu memungkinkan deteksi pola yang memengaruhi produktivitas, seperti tren kelembapan, suhu, atau konsentrasi nutrisi dalam tanah. Dengan pengelolaan data historis yang baik, sistem dapat menghasilkan laporan dan insight yang mendukung pengambilan keputusan berbasis data.

3. **Ketersediaan Data untuk Layanan Real-Time**
   - Server ini menyediakan data yang terus diperbarui untuk mendukung fitur dasbor dan notifikasi real-time di tahap selanjutnya. Struktur dan penyimpanan data yang efisien memastikan integrasi yang lancar antara sistem dan antarmuka pengguna, memudahkan pemantauan dan pengaturan perangkat dari jarak jauh.

Oleh karena itu, fokus pada **Pengembangan Server Kustom** sebagai pusat penyimpanan dan pengelolaan data di Tahap 3 akan membangun fondasi teknis yang kuat, memungkinkan pengelolaan data yang optimal dan berkelanjutan untuk HortiLink.

---

### Kreteria rancangan

1. Platform : Next.js versi terbaru dengan typescript serta app-router
2. Style : Tailwind css dan flowbite
3. Server/hosting : netlify
4. Database : MongoDB Atlas, mongose (ODM)
5. Integrated Development Editor (IDE) : vs-code
6. Memanfaatkan ESLint dan Prettier agar menjaga kode tetap konsisten
7. Pattern menggunakan MVC dan atomic design

---

- **1. Platform: Next.js Versi Terbaru dengan TypeScript dan App Router**

Pemilihan **Next.js** sebagai platform utama didasarkan pada keunggulannya dalam mengembangkan aplikasi web yang cepat, dinamis, dan skalabel. Next.js versi terbaru dilengkapi dengan dukungan **TypeScript** yang memungkinkan penulisan kode yang lebih aman dan bebas dari kesalahan tipe data, yang sangat penting untuk proyek berbasis data seperti HortiLink. Dengan menggunakan **app-router** sebagai pengatur rute utama, aplikasi ini mendapatkan manfaat penuh dari kemampuan server dan client routing yang mulus, mengoptimalkan kinerja dan pengalaman pengguna dalam menjelajahi berbagai fitur.

- **2. Style: Tailwind CSS dan Flowbite**

Dalam hal styling dan antarmuka pengguna, **Tailwind CSS** dan **Flowbite** dipilih untuk memberikan pendekatan desain yang fleksibel dan cepat. **Tailwind CSS** adalah framework CSS yang berbasis utility-first, yang memungkinkan pengembang untuk membangun desain yang sepenuhnya responsif dengan efisiensi tinggi. Kombinasi dengan **Flowbite**, komponen UI berbasis Tailwind yang siap pakai, memungkinkan pengembangan antarmuka yang konsisten dan mudah digunakan. Solusi ini memberikan dasar desain yang modern dan responsif, memastikan tampilan yang profesional di berbagai perangkat, termasuk desktop dan mobile.

- **3. Server/Hosting: Netlify**

**Netlify** dipilih sebagai server hosting untuk mendukung otomatisasi proses build dan deploy. Netlify menyediakan integrasi yang seamless dengan Git, memungkinkan pengembangan dan pengujian berkelanjutan setiap kali ada pembaruan kode. Kemampuan Netlify dalam menangani deployment dengan optimasi untuk static dan server-side rendering di Next.js juga menjadikannya pilihan ideal untuk aplikasi yang memerlukan kecepatan akses tinggi. Selain itu, Netlify mempermudah pengelolaan lingkungan variabel untuk menyimpan kredensial dan API key yang dibutuhkan aplikasi.

- **4. Database: MongoDB Atlas dengan Mongoose (ODM)**

Untuk penyimpanan data, **MongoDB Atlas** digunakan sebagai basis data NoSQL yang dikelola di cloud, memberikan skalabilitas tinggi yang diperlukan untuk menangani volume data sensor yang terus meningkat. **Mongoose** sebagai **Object Data Modeling (ODM)** dipilih untuk memberikan struktur data yang lebih ketat pada MongoDB, sehingga memudahkan pengembang dalam memvalidasi, mengelola, dan memanipulasi data di dalam aplikasi. Dengan MongoDB Atlas, aplikasi dapat memanfaatkan keamanan bawaan, backup otomatis, dan replikasi data yang memastikan keandalan dan ketersediaan data secara konsisten.

- **5. Integrated Development Editor (IDE): Visual Studio Code**

**Visual Studio Code (VS Code)** digunakan sebagai **Integrated Development Environment (IDE)** utama, karena kemudahan penggunaannya, kustomisasi yang tinggi, dan dukungan ekosistem ekstensi yang kaya. VS Code mendukung TypeScript, linting, debugging, dan fitur-fitur produktivitas lainnya, termasuk integrasi langsung dengan Git. Dengan ekstensi tambahan untuk linting dan format, seperti ESLint dan Prettier, serta konektivitas ke MongoDB, VS Code memberikan pengalaman pengembangan yang terintegrasi penuh untuk setiap aspek proyek HortiLink.

- **6. Menggunakan ESLint dan Prettier untuk Konsistensi Kode**

Untuk menjaga kualitas dan konsistensi kode, **ESLint** dan **Prettier** diterapkan. **ESLint** berfungsi sebagai linter kode yang mendeteksi potensi kesalahan dan memastikan standar kode yang konsisten, sesuai dengan praktik terbaik. **Prettier** digunakan sebagai alat pemformatan otomatis yang memastikan kode tetap bersih, terstruktur, dan mengikuti gaya penulisan yang seragam. Dengan menerapkan kedua alat ini, proyek HortiLink akan memiliki kode yang lebih mudah dipelihara, dibaca, dan dikembangkan, serta meminimalisir kesalahan sintaks dan ketidakkonsistenan.

- **7. Pattern: Menggunakan MVC dan Atomic Design**

Proyek ini menggunakan pendekatan **Model-View-Controller (MVC)** dan **Atomic Design** untuk arsitektur dan desain komponen. **MVC** adalah pola arsitektur yang memisahkan aplikasi menjadi tiga bagian utama:

- **Model** untuk mengelola data dan logika bisnis,
- **View** untuk antarmuka pengguna,
- **Controller** untuk menghubungkan Model dan View, menangani logika aplikasi, dan merespons tindakan pengguna.

Pola ini memudahkan dalam pengembangan modular dan memungkinkan tim untuk bekerja pada bagian aplikasi secara terpisah tanpa mengganggu keseluruhan sistem.

**Atomic Design**, di sisi lain, adalah pendekatan desain komponen yang memecah antarmuka pengguna menjadi bagian-bagian yang lebih kecil dan dapat digunakan kembali, mulai dari atom (elemen terkecil) hingga organisme (kumpulan komponen kompleks). Dengan menerapkan Atomic Design pada HortiLink, setiap elemen UI menjadi modular, dapat digunakan ulang, dan mudah dikelola, menjadikan antarmuka pengguna lebih konsisten dan fleksibel untuk dikembangkan.

---

### **Setup Project**

Tentu! Berikut ini adalah langkah-langkah setup awal proyek HortiLink dengan kriteria yang disebutkan, yaitu menggunakan **Next.js** (dengan **TypeScript** dan **app-router**), **Tailwind CSS** serta **Flowbite**, **Netlify** sebagai server hosting, dan **MongoDB Atlas** sebagai database.

- **Langkah 1: Membuat Proyek Next.js dengan TypeScript**

1. **Instalasi Proyek Next.js dengan TypeScript**
   Jalankan perintah berikut untuk membuat proyek Next.js baru dengan TypeScript:

   ```bash
   npx create-next-app@latest hortilink --typescript
   cd hortilink
   ```

   Proyek ini akan terbuat dengan `app-router` secara default di Next.js versi terbaru (sejak versi 13).

2. **Menjalankan Server Pengembangan**
   Pastikan semuanya berjalan dengan baik dengan menjalankan:
   ```bash
   npm run dev
   ```
   Akses aplikasi pada `http://localhost:3000` untuk melihat halaman awal.

- **Langkah 2: Konfigurasi Tailwind CSS dan Flowbite**

1. **Instalasi Tailwind CSS**
   Instal Tailwind CSS dan dependensi yang diperlukan:

   ```bash
   npm install -D tailwindcss postcss autoprefixer
   npx tailwindcss init -p
   ```

2. **Konfigurasi Tailwind**
   Di dalam file `tailwind.config.js`, tambahkan lokasi file yang akan digunakan untuk menulis CSS:

   ```javascript
   /** @type {import('tailwindcss').Config} */
   module.exports = {
     content: [
       './app/**/*.{js,ts,jsx,tsx}',
       './pages/**/*.{js,ts,jsx,tsx}',
       './components/**/*.{js,ts,jsx,tsx}',
       './node_modules/flowbite-react/**/*.js',
     ],
     theme: {
       extend: {},
     },
     plugins: [require('flowbite/plugin')],
   }
   ```

3. **Buat File CSS Utama**
   Buat file `globals.css` di dalam folder `styles` (gantilah isi file jika sudah ada) dan tambahkan konfigurasi berikut:

   ```css
   @tailwind base;
   @tailwind components;
   @tailwind utilities;
   ```

4. **Instalasi Flowbite**
   Tambahkan Flowbite dan Flowbite React:

   ```bash
   npm install flowbite flowbite-react
   ```

5. **Integrasi Flowbite di Next.js**
   Import `globals.css` di file `app/layout.tsx` agar Tailwind CSS dan Flowbite bisa digunakan di seluruh halaman:
   ```typescript
   import '../styles/globals.css'
   ```

- **Langkah 3: Mengatur Koneksi ke MongoDB Atlas**

1. **Buat Database di MongoDB Atlas**

   - Buat akun di [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) jika belum punya.
   - Buat kluster baru dan tambahkan database bernama `hortilink`.
   - Buat user dan password untuk akses database, dan simpan connection string, misalnya:
     ```
     mongodb+srv://<username>:<password>@clustername.mongodb.net/hortilink?retryWrites=true&w=majority
     ```

2. **Instalasi Mongoose untuk Next.js**
   Instal Mongoose sebagai ODM (Object Data Modeling) untuk menghubungkan aplikasi ke MongoDB:

   ```bash
   npm install mongoose
   ```

3. **Konfigurasi Koneksi MongoDB**
   Buat file `lib/mongodb.ts` untuk mengatur koneksi ke MongoDB:

   ```typescript
   import mongoose from 'mongoose'

   const MONGODB_URI = process.env.MONGODB_URI as string

   if (!MONGODB_URI) {
     throw new Error('Please define the MONGODB_URI environment variable inside .env.local')
   }

   let cached = global.mongoose

   if (!cached) {
     cached = global.mongoose = { conn: null, promise: null }
   }

   async function dbConnect() {
     if (cached.conn) {
       return cached.conn
     }

     if (!cached.promise) {
       const opts = {
         bufferCommands: false,
       }

       cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
         return mongoose
       })
     }
     cached.conn = await cached.promise
     return cached.conn
   }

   export default dbConnect
   ```

4. **Menambahkan Variabel Lingkungan**
   Buat file `.env.local` di root proyek, lalu tambahkan connection string MongoDB:

   ```env
   MONGODB_URI=mongodb+srv://<username>:<password>@clustername.mongodb.net/hortilink?retryWrites=true&w=majority
   ```

5. **Inisialisasi Database dalam Komponen Next.js**
   Pada komponen atau halaman yang memerlukan akses ke MongoDB, import `dbConnect` dan panggil di dalam `getServerSideProps` atau API route.

   Contoh di API route `app/api/sensordata/route.ts`:

   ```typescript
   import { NextResponse } from 'next/server'
   import dbConnect from '../../../lib/mongodb'
   import SensorData from '../../../models/sensorData' // Buat model seperti pada langkah sebelumnya

   export async function GET() {
     await dbConnect()
     const data = await SensorData.find({})
     return NextResponse.json(data)
   }
   ```

- **Langkah 4: Deploy ke Netlify**

1. **Instal Netlify CLI (Opsional)**
   Instal Netlify CLI jika ingin mengelola deploy melalui terminal:

   ```bash
   npm install -g netlify-cli
   ```

2. **Push Proyek ke GitHub atau GitLab**
   Netlify akan mengambil source code dari repositori GitHub atau GitLab. Pastikan proyek di-push ke repositori.

3. **Konfigurasi Build di Netlify**

   - Masuk ke akun [Netlify](https://www.netlify.com/) dan buat proyek baru dengan menghubungkan ke repositori.
   - Tambahkan variabel environment `MONGODB_URI` di pengaturan Netlify, sama seperti yang ada di `.env.local`.

4. **Build Command dan Publish Directory**

   - **Build Command**: `npm run build`
   - **Publish Directory**: `out`

5. **Jalankan Deploy**
   Netlify akan otomatis membangun dan menerbitkan aplikasi berdasarkan pengaturan ini.

- **Langkah 5: Pengaturan VS Code**

1. **Instalasi Ekstensi VS Code**

   - **Tailwind CSS IntelliSense**: Menambahkan dukungan autocompletion untuk Tailwind CSS.
   - **ESLint dan Prettier**: Untuk menjaga konsistensi dan kualitas kode.
   - **MongoDB for VS Code**: Jika ingin mengelola MongoDB langsung dari VS Code.

2. **Konfigurasi ESLint dan Prettier**
   Jika ingin menjaga kode tetap konsisten, tambahkan konfigurasi ESLint dan Prettier dengan TypeScript di proyek Anda.
   Penggunaan **ESLint** dan **Prettier** sangat membantu dalam pengembangan proyek, terutama dalam menjaga kualitas dan konsistensi kode. Berikut ini fungsi dan keuntungan utama dari keduanya:

---

#### **Lebih lanjut ESLint & Prettier**

- **1. ESLint: Fungsi dan Keuntungan**

**Fungsi ESLint:**

- **Linting (Pengecekan Kode)**: ESLint memeriksa kode untuk menemukan dan menandai masalah potensial seperti kesalahan sintaks, penggunaan variabel yang tidak dideklarasikan, atau kode yang tidak digunakan.
- **Enforcing Best Practices**: ESLint membantu menjaga standar kode dengan memperingatkan jika ada pola yang tidak sesuai dengan praktik terbaik, misalnya, kesalahan penggunaan React Hooks atau penamaan yang tidak konsisten.
- **Mendeteksi Bug Lebih Dini**: Dengan linting otomatis, ESLint dapat mendeteksi bug atau kesalahan kecil sebelum mereka menjadi masalah besar. Misalnya, saat ada variabel yang typo atau tidak diimpor dengan benar.

**Keuntungan ESLint:**

- **Konsistensi Kode**: Dengan aturan yang sama untuk semua pengembang di tim, kode menjadi konsisten dan mudah dibaca.
- **Efisiensi Review Kode**: Mengurangi waktu untuk revisi manual saat review, karena banyak kesalahan sudah diperbaiki oleh ESLint.
- **Mengurangi Bug di Produksi**: Deteksi dini terhadap kesalahan yang mungkin muncul di runtime, sehingga aplikasi lebih stabil dan andal.

- **2. Prettier: Fungsi dan Keuntungan**

  **Fungsi Prettier:**

  - **Formatter Kode**: Prettier secara otomatis memformat kode agar rapi dan seragam. Ini mencakup aspek seperti penempatan kurung, indentasi, panjang baris, dan penggunaan tanda koma.
  - **Menghilangkan Debat Gaya Kode**: Dengan Prettier, tim tidak perlu mendebatkan gaya penulisan kode, karena Prettier menerapkan gaya yang sama ke semua bagian kode secara otomatis.

  **Keuntungan Prettier:**

  - **Meningkatkan Readability**: Dengan format yang konsisten, kode menjadi lebih mudah dibaca dan dipahami, terutama dalam tim yang besar.
  - **Hemat Waktu**: Developer tidak perlu memformat kode secara manual, sehingga fokus bisa dialihkan ke pengembangan fitur.
  - **Konsistensi Estetika**: Mencegah ketidakkonsistenan estetika, seperti indentasi yang tidak seragam atau panjang baris yang berlebihan.

- **Mengapa Menggunakan Keduanya Bersamaan?**

  - **Kolaborasi Optimal**: ESLint menangani masalah kualitas dan praktik terbaik, sementara Prettier menjaga penampilan dan estetika kode. Bersama-sama, keduanya menciptakan standar yang konsisten dan mudah diterapkan oleh semua pengembang di tim.
  - **Integrasi Otomatis**: Dengan konfigurasi yang tepat, Prettier dapat dijalankan sebagai bagian dari ESLint. Ini memastikan kode bebas dari kesalahan sekaligus tampak rapi secara otomatis, tanpa langkah tambahan.

  Singkatnya, **ESLint** dan **Prettier** bersama-sama membuat proses pengembangan lebih rapi, konsisten, dan minim kesalahan. Ini sangat membantu menjaga kualitas kode di proyek yang berkembang, terutama dalam tim pengembang yang lebih besar.

---

#### **Konfigurasi ESLint & Prettier**

Konfigurasi **ESLint** dan **Prettier** bisa dilakukan dengan mudah, dan sebagian besar bisa diotomatisasi dengan beberapa perintah. Mari ikuti langkah-langkah berikut untuk menyiapkan **ESLint** dan **Prettier** secara otomatis di proyek **Next.js** dengan **TypeScript**.

- **1. Instalasi ESLint dan Prettier beserta Plugin Pendukung**

  Jalankan perintah berikut di terminal proyek untuk menginstal **ESLint**, **Prettier**, dan plugin yang dibutuhkan:

  ```bash
  npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-a11y @typescript-eslint/parser @typescript-eslint/eslint-plugin
  ```

  Penjelasan singkat tentang setiap package:

  - **eslint**: Linter utama untuk mendeteksi dan memperbaiki masalah sintaks.
  - **prettier**: Formatter untuk menjaga konsistensi kode.
  - **eslint-config-prettier**: Menonaktifkan aturan ESLint yang bisa bertentangan dengan Prettier.
  - **eslint-plugin-prettier**: Menjalankan Prettier sebagai aturan ESLint.
  - **@typescript-eslint/parser** dan **@typescript-eslint/eslint-plugin**: Mendukung linting untuk TypeScript.
  - **eslint-plugin-react**, **eslint-plugin-react-hooks**, dan **eslint-plugin-jsx-a11y**: Plugin yang disarankan untuk proyek berbasis React agar kodenya lebih sesuai dengan standar aksesibilitas dan praktik terbaik.

- **2. Inisialisasi Konfigurasi ESLint**

  Jalankan perintah berikut untuk membuat file konfigurasi `.eslintrc.json`:

  ```bash
  npx eslint --init
  ```

  Saat diminta, pilih opsi berikut:

  1.  **How would you like to use ESLint?**: Choose "To check syntax, find problems, and enforce code style".
  2.  **What type of modules does your project use?**: Choose "JavaScript modules (import/export)".
  3.  **Which framework does your project use?**: Choose "React".
  4.  **Does your project use TypeScript?**: Choose "Yes".
  5.  **Where does your code run?**: Choose "Browser".
  6.  **What format do you want your config file to be in?**: Choose "JSON".

  Setelah selesai, file `.eslintrc.json` akan dihasilkan, dan kita akan menambahkan beberapa konfigurasi tambahan di langkah berikutnya.

- **3. Menambahkan Konfigurasi ke `.eslintrc.json`**

  Edit file `.eslintrc.json` agar kompatibel dengan Prettier dan TypeScript. Berikut adalah contoh konfigurasi yang lengkap:

  ```json
  {
    "env": {
      "browser": true,
      "es2021": true
    },
    "extends": [
      "eslint:recommended",
      "plugin:react/recommended",
      "plugin:@typescript-eslint/recommended",
      "plugin:react-hooks/recommended",
      "plugin:jsx-a11y/recommended",
      "plugin:prettier/recommended"
    ],
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
      "ecmaFeatures": {
        "jsx": true
      },
      "ecmaVersion": "latest",
      "sourceType": "module"
    },
    "plugins": ["react", "@typescript-eslint", "prettier"],
    "rules": {
      "prettier/prettier": "error",
      "react/react-in-jsx-scope": "off", // Khusus Next.js, karena React diimpor otomatis
      "@typescript-eslint/explicit-module-boundary-types": "off"
    },
    "settings": {
      "react": {
        "version": "detect"
      }
    }
  }
  ```

  Konfigurasi ini mengatur ESLint untuk:

  - Menggunakan plugin **Prettier** dan menandai error jika kode tidak mengikuti format Prettier.
  - Mendukung **React**, **React Hooks**, **JSX Accessibility**, dan **TypeScript** dengan linting yang tepat.
  - Menonaktifkan beberapa aturan yang kurang relevan untuk proyek Next.js, seperti impor `React` secara eksplisit.

- **4. Buat Konfigurasi Prettier**

  Buat file konfigurasi **Prettier** dengan nama `.prettierrc` di root proyek Anda:

  ```json
  {
    "semi": true,
    "singleQuote": true,
    "tabWidth": 2,
    "printWidth": 80,
    "trailingComma": "es5",
    "arrowParens": "avoid"
  }
  ```

  File ini mengatur gaya format seperti penggunaan titik koma, tanda kutip tunggal, lebar baris, dan lain-lain sesuai preferensi umum.

- **5. Tambahkan Ignore Files**

  Agar ESLint dan Prettier tidak memeriksa file yang tidak diperlukan, buat file `.eslintignore` dan `.prettierignore` di root proyek. Contoh isi dari kedua file ini:

  **.eslintignore**

  ```
  node_modules/
  .next/
  out/
  ```

  **.prettierignore**

  ```
  node_modules/
  .next/
  out/
  ```

- **6. Menambahkan Script di `package.json`**

  Tambahkan script berikut di `package.json` untuk menjalankan ESLint dan Prettier secara otomatis:

  ```json
  "scripts": {
  "lint": "eslint . --ext .js,.jsx,.ts,.tsx",
  "lint:fix": "eslint . --ext .js,.jsx,.ts,.tsx --fix",
  "format": "prettier --write ."
  }
  ```

  - **lint**: Mengecek kode menggunakan ESLint.
  - **lint:fix**: Mengecek dan memperbaiki masalah ESLint secara otomatis.
  - **format**: Menjalankan Prettier untuk memformat seluruh proyek.

- **7. Konfigurasi VS Code untuk Mendukung ESLint dan Prettier**

  Instal ekstensi **ESLint** dan **Prettier - Code Formatter** di VS Code untuk mendukung linting dan formatting secara otomatis.

  Tambahkan juga pengaturan berikut di `settings.json` VS Code untuk mengaktifkan format otomatis saat penyimpanan file:

  ```json
  {
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
      "source.fixAll.eslint": true
    }
  }
  ```

- **Langkah Tambahan: Memastikan Integrasi Otomatis**

  Sekarang Anda dapat menjalankan linting dan format secara otomatis setiap kali menyimpan file di VS Code. Anda juga bisa menjalankan perintah berikut untuk linting dan format manual:

  ```bash
  npm run lint
  npm run format
  ```

---

### **Pattern MVC dan Atomic Design**

Menggabungkan **MVC** dengan **Atomic Design** adalah pilihan yang sangat baik untuk membuat aplikasi seperti **HortiLink** menjadi lebih terstruktur dan terorganisir! Dengan pendekatan ini, kita bisa menjaga logika bisnis dan manajemen data dalam pola **MVC**, sambil merapikan antarmuka pengguna dengan menggunakan **Atomic Design** untuk komponen UI. Ini memberikan struktur kode yang lebih modular dan rapi, terutama ketika berhadapan dengan fitur kompleks dan antarmuka yang kaya.

Berikut cara mengimplementasikan kombinasi **MVC** dan **Atomic Design** di Next.js:

---

- **1. Konsep Penggabungan MVC dan Atomic Design**

- **MVC (Model-View-Controller)**: Fokus pada pemisahan antara data (Model), logika bisnis (Controller), dan tampilan (View). MVC akan mengelola data dan logika aplikasi.
- **Atomic Design**: Struktur desain UI dari komponen kecil (_Atoms_) hingga komponen kompleks (_Molecules_, _Organisms_, _Templates_, dan _Pages_). Atomic Design mengatur komponen UI agar reusable dan terstruktur.

- **2. Struktur Folder**

Kita akan membagi proyek ke dalam dua bagian utama:

- **MVC Structure**: Di sini akan ada folder `models`, `controllers`, dan `services`.
- **Atomic Design Structure**: Folder `components` akan dibagi menjadi `atoms`, `molecules`, `organisms`, `templates`, dan `pages`.

Berikut adalah contoh struktur foldernya:

```plaintext
hortilink/
â”œâ”€â”€ app/                        # App Router untuk API dan halaman
â”‚   â”œâ”€â”€ api/                    # API routes Next.js
â”‚   â”‚   â”œâ”€â”€ farm/               # API untuk data kebun
â”‚   â”‚   â””â”€â”€ sensor/             # API untuk data sensor
â”‚   â”œâ”€â”€ farm/                   # Halaman untuk fitur kebun
â”‚   â”‚   â””â”€â”€ page.tsx            # Halaman daftar kebun
â”‚   â””â”€â”€ sensor/                 # Halaman untuk fitur sensor
â”‚       â””â”€â”€ page.tsx            # Halaman daftar data sensor
â”œâ”€â”€ components/                 # Atomic Design untuk UI
â”‚   â”œâ”€â”€ atoms/                  # Komponen terkecil seperti button, input
â”‚   â”œâ”€â”€ molecules/              # Gabungan atoms, misalnya form field
â”‚   â”œâ”€â”€ organisms/              # Gabungan molecules, misalnya form atau tabel lengkap
â”‚   â”œâ”€â”€ templates/              # Layout atau template halaman
â”‚   â””â”€â”€ pages/                  # Halaman lengkap dengan layout dan komponen
â”œâ”€â”€ controllers/                # Controller untuk logika bisnis
â”‚   â”œâ”€â”€ FarmController.ts       # Logika bisnis untuk kebun
â”‚   â””â”€â”€ SensorController.ts     # Logika bisnis untuk data sensor
â”œâ”€â”€ models/                     # Model database menggunakan Mongoose
â”‚   â”œâ”€â”€ FarmModel.ts            # Model data untuk kebun
â”‚   â””â”€â”€ SensorDataModel.ts      # Model data untuk sensor
â”œâ”€â”€ services/                   # Service untuk logika umum dan helper
â”‚   â””â”€â”€ db.ts                   # Koneksi database MongoDB
â””â”€â”€ utils/                      # Utilitas umum
    â””â”€â”€ apiHelpers.ts
```

- **3. Implementasi MVC**

  - a. **Model**

  Model ini akan berfungsi sebagai representasi data di MongoDB. Misalnya, kita bisa membuat model `FarmModel` untuk kebun dan `SensorDataModel` untuk data sensor.

  ```typescript
  // models/FarmModel.ts
  import mongoose, { Schema, model, models } from 'mongoose'

  const farmSchema = new Schema({
    name: { type: String, required: true },
    luas: { type: Number, required: true },
    lokasi: { type: String, required: true },
    jenisSayuran: { type: String, required: true },
  })

  const FarmModel = models.Farm || model('Farm', farmSchema)

  export default FarmModel
  ```

  ```typescript
  // models/SensorDataModel.ts
  import mongoose, { Schema, model, models } from 'mongoose'

  const sensorDataSchema = new Schema({
    farmId: { type: mongoose.Schema.Types.ObjectId, ref: 'Farm', required: true },
    suhu: { type: Number, required: true },
    humidity: { type: Number, required: true },
    ec_tds: { type: Number, required: true },
    timestamp: { type: Date, default: Date.now },
  })

  const SensorDataModel = models.SensorData || model('SensorData', sensorDataSchema)

  export default SensorDataModel
  ```

  - b. **Controller**

  Controller akan mengelola logika bisnis. Di Next.js, kita akan memanggil controller ini di dalam API Routes di `app/api`.

  ```typescript
  // controllers/FarmController.ts
  import FarmModel from '../models/FarmModel'
  import dbConnect from '../services/db'

  export default class FarmController {
    static async getAllFarms() {
      await dbConnect()
      return FarmModel.find({})
    }

    static async createFarm(data: any) {
      await dbConnect()
      return FarmModel.create(data)
    }
  }
  ```

  - c. **Service Layer**

  Tambahkan service untuk koneksi database agar dapat digunakan di seluruh controller:

  ```typescript
  // services/db.ts
  import mongoose from 'mongoose'

  const MONGODB_URI = process.env.MONGODB_URI || ''

  if (!MONGODB_URI) {
    throw new Error('Please define the MONGODB_URI environment variable')
  }

  let cached = global.mongoose

  if (!cached) {
    cached = global.mongoose = { conn: null, promise: null }
  }

  async function dbConnect() {
    if (cached.conn) return cached.conn

    if (!cached.promise) {
      cached.promise = mongoose.connect(MONGODB_URI).then((mongoose) => mongoose)
    }
    cached.conn = await cached.promise
    return cached.conn
  }

  export default dbConnect
  ```

- **4. Implementasi Atomic Design untuk Komponen UI**

  Di sini, kita akan membuat antarmuka pengguna berdasarkan prinsip Atomic Design:

  - **Atoms**: Komponen UI terkecil, seperti tombol atau input.
  - **Molecules**: Gabungan beberapa atoms, seperti field input lengkap dengan label.
  - **Organisms**: Gabungan beberapa molecules, misalnya tabel yang berisi data sensor atau data kebun.
  - **Templates**: Layout atau struktur halaman yang digunakan berulang kali.
  - **Pages**: Halaman penuh yang berisi semua komponen dan layout.

  - Contoh Implementasi Komponen Atomic Design

    - a. **Atoms**

    Misalnya, tombol sederhana `Button.tsx` di `components/atoms`:

    ```typescript
    // components/atoms/Button.tsx
    import React from 'react';

    type ButtonProps = {
      text: string;
      onClick: () => void;
      className?: string;
    };

    const Button: React.FC<ButtonProps> = ({ text, onClick, className }) => (
      <button onClick={onClick} className={`px-4 py-2 bg-blue-500 text-white rounded ${className}`}>
        {text}
      </button>
    );

    export default Button;
    ```

    - b. **Molecules**

    Field input yang lebih kompleks dengan label di `components/molecules/InputField.tsx`:

    ```typescript
    // components/molecules/InputField.tsx
    import React from 'react';

    type InputFieldProps = {
      label: string;
      value: string;
      onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    };

    const InputField: React.FC<InputFieldProps> = ({ label, value, onChange }) => (
      <div>
        <label className="block text-gray-700 text-sm font-bold mb-2">{label}</label>
        <input
          type="text"
          value={value}
          onChange={onChange}
          className="border rounded py-2 px-3 w-full"
        />
      </div>
    );

    export default InputField;
    ```

    - c. **Organisms**

    Tabel data sensor di `components/organisms/SensorTable.tsx`:

    ```typescript
    // components/organisms/SensorTable.tsx
    import React from 'react';

    type SensorData = {
      _id: string;
      suhu: number;
      humidity: number;
      ec_tds: number;
      timestamp: string;
    };

    const SensorTable: React.FC<{ data: SensorData[] }> = ({ data }) => (
      <table className="table-auto w-full">
        <thead>
          <tr>
            <th>Suhu</th>
            <th>Humidity</th>
            <th>EC/TDS</th>
            <th>Timestamp</th>
          </tr>
        </thead>
        <tbody>
          {data.map((sensor) => (
            <tr key={sensor._id}>
              <td>{sensor.suhu}Â°C</td>
              <td>{sensor.humidity}%</td>
              <td>{sensor.ec_tds} ÂµS/cm</td>
              <td>{new Date(sensor.timestamp).toLocaleString()}</td>
            </tr>
          ))}
        </tbody>
      </table>
    );

    export default SensorTable;
    ```

---

- **5. Mengintegrasikan di Halaman**

Di **App Router**, kita bisa menggunakan struktur ini dalam halaman `app/farm/page.tsx` atau `app/sensor/page.tsx`, menggabungkan komponen dari Atomic Design dan mengakses data melalui controller.

---

### Hak cipta[^1]. Artikel ini berdasar ChatGpt & penulis tidak menjamin seluruh akurasi isinya

[^1]: [ChatGpt](https://chat.openai.com)
